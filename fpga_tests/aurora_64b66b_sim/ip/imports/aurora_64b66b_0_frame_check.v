 //////////////////////////////////////////////////////////////////////////////
 // Project:  Aurora 64B/66B
 // Company:  Xilinx
 //
 //
 //
 // (c) Copyright 2008 - 2009 Xilinx, Inc. All rights reserved.
 //
 // This file contains confidential and proprietary information
 // of Xilinx, Inc. and is protected under U.S. and
 // international copyright and other intellectual property
 // laws.
 //
 // DISCLAIMER
 // This disclaimer is not a license and does not grant any
 // rights to the materials distributed herewith. Except as
 // otherwise provided in a valid license issued to you by
 // Xilinx, and to the maximum extent permitted by applicable
 // law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
 // WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
 // AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
 // BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
 // INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
 // (2) Xilinx shall not be liable (whether in contract or tort,
 // including negligence, or under any other theory of
 // liability) for any loss or damage of any kind or nature
 // related to, arising under or in connection with these
 // materials, including for any direct, or any indirect,
 // special, incidental, or consequential loss or damage
 // (including loss of data, profits, goodwill, or any type of
 // loss or damage suffered as a result of any action brought
 // by a third party) even if such damage or loss was
 // reasonably foreseeable or Xilinx had been advised of the
 // possibility of the same.
 //
 // CRITICAL APPLICATIONS
 // Xilinx products are not designed or intended to be fail-
 // safe, or for use in any application requiring fail-safe
 // performance, such as life-support or safety devices or
 // systems, Class III medical devices, nuclear facilities,
 // applications related to the deployment of airbags, or any
 // other applications that could lead to death, personal
 // injury, or severe property or environmental damage
 // (individually and collectively, "Critical
 // Applications"). Customer assumes the sole risk and
 // liability of any use of Xilinx products in Critical
 // Applications, subject only to applicable laws and
 // regulations governing limitations on product liability.
 //
 // THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
 // PART OF THIS FILE AT ALL TIMES.
 
 //
 //////////////////////////////////////////////////////////////////////////////
 //
 //  FRAME CHECK
 //
 //
 //
 //  Description: This module is a  pattern checker to test the Aurora
 //               designs in hardware. The frames generated by FRAME_GEN
 //               pass through the Aurora channel and arrive at the frame checker 
 //               through the RX User interface. Every time an error is found in
 //               the data recieved, the error count is incremented until it 
 //               reaches its max value.
 //////////////////////////////////////////////////////////////////////////////
 
 `timescale 1 ns / 10 ps
 `define DLY #1
 
(* DowngradeIPIdentifiedWarnings="yes" *)
 module aurora_64b66b_0_FRAME_CHECK
 (
     // User Interface
     RX_D,  
     RX_REM,
     RX_SOF_N,
     RX_EOF_N,
     RX_SRC_RDY_N,  
     DATA_ERR_COUNT,
 
 
 
     // System Interface
     CHANNEL_UP,
     USER_CLK,       
     RESET4RX,
     RESET
   
 );
 //*********************** Parameter Declarations************************
     parameter            AURORA_LANES    = 1;
     parameter            LANE_DATA_WIDTH = (AURORA_LANES*64);
     parameter            REM_BUS         = 3;
     parameter            DATA_WIDTH      = 8;
 
 //***********************************Port Declarations*******************************
     //PDU Interface
     input     [0:LANE_DATA_WIDTH-1]    RX_D;
     input     [0:REM_BUS-1]            RX_REM;
     input                              RX_SOF_N; 
     input                              RX_EOF_N; 
     input                              RX_SRC_RDY_N; 
     
     //System Interface
     input                              CHANNEL_UP; 
     input                              USER_CLK; 
     input                              RESET;  
       input                            RESET4RX;  
     output    [0:DATA_WIDTH-1]         DATA_ERR_COUNT;
 
 //***************************Internal Register Declarations*************************** 
 
     //PDU interface signals
     reg       [0:DATA_WIDTH-1]         DATA_ERR_COUNT; 
     reg       [0:15]                   pdu_lfsr_r;
     reg       [LANE_DATA_WIDTH-1:0]    pdu_cmp_data_r;
     reg       [0:LANE_DATA_WIDTH-1]    RX_D_R;  
     reg                                pdu_data_valid_r;
     reg                                pdu_in_frame_r;
     reg       [0:AURORA_LANES-1]                   pdu_err_detected_c;
     wire       [0:LANE_DATA_WIDTH-1]    pdu_cmp_data_r1;
     wire      [0:AURORA_LANES-1]                   data_err_c; 

 (* shift_extract = "{no}"*)    reg       [0:LANE_DATA_WIDTH-1]    RX_D_R2;
 (* shift_extract = "{no}"*)    reg       [0:REM_BUS-1]            RX_REM_R2;
 (* shift_extract = "{no}"*)    reg       [0:REM_BUS-1]            RX_REM_R3;
 (* shift_extract = "{no}"*)    reg                                RX_SOF_N_R2;
 (* shift_extract = "{no}"*)    reg                                RX_EOF_N_R2;
 (* shift_extract = "{no}"*)    reg                                RX_SRC_RDY_N_R2; 
 
     wire                               pdu_in_frame_c;
     wire      [0:LANE_DATA_WIDTH-1]    pdu_lfsr_concat_w;  
     wire                               pdu_data_valid_c;
 
     wire                               reset_i; 
     wire                               RESET_ii; 

    reg firstData_r;
    reg firstData_r2;

    wire firstDataChk;
    wire chk_data;
    reg  firstDataChk_r;

 //*********************************Main Body of Code**********************************
 
   assign reset_i = RESET || RESET4RX || (!CHANNEL_UP);

    assign RESET_ii = RESET || RESET4RX; 

  /*****************************PDU Data Genetration & Checking**********************/


    always @ (posedge USER_CLK)
    begin
        if (RESET_ii)
           firstData_r <= `DLY 1'b0;
        else if (RX_D[0:15] == 16'hD5E6) 
           firstData_r <= `DLY 1'b1;
    end
     
    always @ (posedge USER_CLK)
    begin
        if (RESET_ii)
           firstData_r2 <= `DLY 1'b0;
        else
           firstData_r2 <= `DLY firstData_r;
    end

    
    assign firstDataChk =  ((RX_D_R[0:15] == 16'hD5E6) && (pdu_cmp_data_r1[0:15] == 16'hD5E6));
     
    always @(posedge USER_CLK)
    begin
        if (RESET_ii)
            firstDataChk_r <= `DLY 1'b0;
        else if (firstDataChk) 
            firstDataChk_r <= `DLY 1'b1;
    end

    assign chk_data = ((firstDataChk || firstDataChk_r) && pdu_data_valid_r); 




 
     //Generate the PDU data using LFSR for data comparision
     always @ (posedge USER_CLK)
     if(reset_i)
       pdu_lfsr_r  <=  `DLY  16'hD5E6;
     else if(pdu_data_valid_c)
       pdu_lfsr_r  <=  `DLY  {!{pdu_lfsr_r[3]^pdu_lfsr_r[12]^pdu_lfsr_r[14]^pdu_lfsr_r[15]}, 
                            pdu_lfsr_r[0:14]};
 
     assign pdu_lfsr_concat_w = {AURORA_LANES*4{pdu_lfsr_r}};

    always @ (posedge USER_CLK)
    begin
       RX_D_R2         <= `DLY RX_D;
       RX_REM_R2       <= `DLY RX_REM; 
       RX_REM_R3       <= `DLY RX_REM;
       RX_SOF_N_R2     <= `DLY RX_SOF_N; 
       RX_EOF_N_R2     <= `DLY RX_EOF_N; 
       RX_SRC_RDY_N_R2 <= `DLY RX_SRC_RDY_N; 
    end

 
     //______________________________ Capture incoming data ___________________________    
 
     //PDU data is valid when RX_SRC_RDY_N_R2 is asserted
     assign pdu_data_valid_c    =  ((firstData_r && !firstData_r2) || (firstData_r && (pdu_in_frame_c && !RX_SRC_RDY_N_R2)));
 
     //PDU data is in a frame if it is a single cycle frame or a multi_cycle frame has started
     assign  pdu_in_frame_c  =   pdu_in_frame_r  ||  (!RX_SRC_RDY_N_R2 && !RX_SOF_N_R2);
 
     //Start a multicycle PDU frame when a frame starts without ending on the same cycle. End 
     //the frame when an RX_EOF_N_R2 is detected
     always @(posedge USER_CLK)
     if(RESET_ii)
       pdu_in_frame_r  <=  `DLY    1'b0;
     else if(!pdu_in_frame_r && !RX_SOF_N_R2 && !RX_SRC_RDY_N_R2 && RX_EOF_N_R2)
       pdu_in_frame_r  <=  `DLY    1'b1;
     else if(pdu_in_frame_r && !RX_SRC_RDY_N_R2 && !RX_EOF_N_R2)
       pdu_in_frame_r  <=  `DLY    1'b0;
 
     //Register and decode the RX_D_R2 data with RX_REM_R2 bus
     always @ (posedge USER_CLK)
     begin 	       
       if((!RX_EOF_N_R2) && (!RX_SRC_RDY_N_R2))
       begin	 
         case(RX_REM_R2)
3'd0 : RX_D_R <=  `DLY RX_D_R2;
3'd1 : RX_D_R <=  `DLY {RX_D_R2[0:7], 56'b0};
3'd2 : RX_D_R <=  `DLY {RX_D_R2[0:15], 48'b0};
3'd3 : RX_D_R <=  `DLY {RX_D_R2[0:23], 40'b0};
3'd4 : RX_D_R <=  `DLY {RX_D_R2[0:31], 32'b0};
3'd5 : RX_D_R <=  `DLY {RX_D_R2[0:39], 24'b0};
3'd6 : RX_D_R <=  `DLY {RX_D_R2[0:47], 16'b0};
3'd7 : RX_D_R <=  `DLY {RX_D_R2[0:55], 8'b0};
           default : RX_D_R  <=  `DLY RX_D_R2; 		 
 	endcase 	 
       end  
       else if(!RX_SRC_RDY_N_R2)
         RX_D_R          <=  `DLY    RX_D_R2;
     end 
 
     //Calculate the expected PDU data 
     always @ (posedge USER_CLK)
     begin
       if(reset_i)
         pdu_cmp_data_r <= `DLY {AURORA_LANES*4{16'hD5E6}};
       else if(pdu_data_valid_c)
       begin		 
         case(RX_REM_R3)
3'd0 : pdu_cmp_data_r <= `DLY pdu_lfsr_concat_w;
3'd1 : pdu_cmp_data_r <=  `DLY {pdu_lfsr_concat_w[0:7], 56'b0};
3'd2 : pdu_cmp_data_r <=  `DLY {pdu_lfsr_concat_w[0:15], 48'b0};
3'd3 : pdu_cmp_data_r <=  `DLY {pdu_lfsr_concat_w[0:23], 40'b0};
3'd4 : pdu_cmp_data_r <=  `DLY {pdu_lfsr_concat_w[0:31], 32'b0};
3'd5 : pdu_cmp_data_r <=  `DLY {pdu_lfsr_concat_w[0:39], 24'b0};
3'd6 : pdu_cmp_data_r <=  `DLY {pdu_lfsr_concat_w[0:47], 16'b0};
3'd7 : pdu_cmp_data_r <=  `DLY {pdu_lfsr_concat_w[0:55], 8'b0};
           default : pdu_cmp_data_r <=  `DLY pdu_lfsr_concat_w; 		 
 	endcase 	 
       end
     end
 
     //PDU Data in the pdu_cmp_data_r register is valid only if it was valid when captured and had no error
     always @(posedge USER_CLK)
       if(reset_i)   
         pdu_data_valid_r    <=  `DLY    1'b0;
       else
         pdu_data_valid_r    <=  `DLY    pdu_data_valid_c && !pdu_err_detected_c;

     //
     assign pdu_cmp_data_r1 = {
       pdu_cmp_data_r[63], 
       pdu_cmp_data_r[62], 
       pdu_cmp_data_r[61], 
       pdu_cmp_data_r[60], 
       pdu_cmp_data_r[59], 
       pdu_cmp_data_r[58], 
       pdu_cmp_data_r[57], 
       pdu_cmp_data_r[56], 
       pdu_cmp_data_r[55], 
       pdu_cmp_data_r[54], 
       pdu_cmp_data_r[53], 
       pdu_cmp_data_r[52], 
       pdu_cmp_data_r[51], 
       pdu_cmp_data_r[50], 
       pdu_cmp_data_r[49], 
       pdu_cmp_data_r[48], 
       pdu_cmp_data_r[47], 
       pdu_cmp_data_r[46], 
       pdu_cmp_data_r[45], 
       pdu_cmp_data_r[44], 
       pdu_cmp_data_r[43], 
       pdu_cmp_data_r[42], 
       pdu_cmp_data_r[41], 
       pdu_cmp_data_r[40], 
       pdu_cmp_data_r[39], 
       pdu_cmp_data_r[38], 
       pdu_cmp_data_r[37], 
       pdu_cmp_data_r[36], 
       pdu_cmp_data_r[35], 
       pdu_cmp_data_r[34], 
       pdu_cmp_data_r[33], 
       pdu_cmp_data_r[32], 
       pdu_cmp_data_r[31], 
       pdu_cmp_data_r[30], 
       pdu_cmp_data_r[29], 
       pdu_cmp_data_r[28], 
       pdu_cmp_data_r[27], 
       pdu_cmp_data_r[26], 
       pdu_cmp_data_r[25], 
       pdu_cmp_data_r[24], 
       pdu_cmp_data_r[23], 
       pdu_cmp_data_r[22], 
       pdu_cmp_data_r[21], 
       pdu_cmp_data_r[20], 
       pdu_cmp_data_r[19], 
       pdu_cmp_data_r[18], 
       pdu_cmp_data_r[17], 
       pdu_cmp_data_r[16], 
       pdu_cmp_data_r[15], 
       pdu_cmp_data_r[14], 
       pdu_cmp_data_r[13], 
       pdu_cmp_data_r[12], 
       pdu_cmp_data_r[11], 
       pdu_cmp_data_r[10], 
       pdu_cmp_data_r[9], 
       pdu_cmp_data_r[8], 
       pdu_cmp_data_r[7], 
       pdu_cmp_data_r[6], 
       pdu_cmp_data_r[5], 
       pdu_cmp_data_r[4], 
       pdu_cmp_data_r[3], 
       pdu_cmp_data_r[2], 
       pdu_cmp_data_r[1], 
       pdu_cmp_data_r[0] 
     };

  assign data_err_c[0] = ( chk_data && (RX_D_R[0:63] != pdu_cmp_data_r1[0:63]));      

 
     //An error is detected when LFSR generated PDU data from the pdu_cmp_data_r register, 
     //does not match valid data from the RX_D port
 always @(posedge USER_CLK)
     pdu_err_detected_c    <=  `DLY    data_err_c;

 
     //Compare the incoming PDU data with calculated expected PDU data.
     //Increment the PDU ERR COUNTER if mismatch occurs
     //Stop the PDU ERR COUNTER once it reaches its max value
     always @ (posedge USER_CLK)
     begin	       
       if(RESET_ii)
         DATA_ERR_COUNT <= `DLY 8'b0;
       else if(!CHANNEL_UP)
         DATA_ERR_COUNT <= `DLY 8'b0;
       else if(&DATA_ERR_COUNT)
         DATA_ERR_COUNT <= `DLY DATA_ERR_COUNT;
       else if(|pdu_err_detected_c)
         DATA_ERR_COUNT <= `DLY DATA_ERR_COUNT + 1; 
       end 
 
 endmodule           
