The result of running the probe on TEF1001-02-B2IX4-A for which have yet to fit the FMC module or DDR3 module was:
[mr_halfword@skylake-alma release]$ i2c_probe/i2c_probe 
Opening device 0000:15:00.0 (10ee:7024) with IOMMU group 25
Using BAR 0 in device 0000:15:00.0 of size 0x2000
Slave 0x40 replied with data 0xff
Slave 0x4f replied with data 0xff
Slave 0x5a replied with data 0xff
Slave 0x5b replied with data 0xff
Slave 0x70 replied with data 0x00
Slave 0x74 replied with data 0xaf

From the documenation under https://shop.trenz-electronic.de/en/TEF1001-02-B2IX4-A-PCIe-FMC-Carrier-with-Xilinx-Kintex-7-160T-4-Lane-PCIe-GEN2-DDR3-SODIMM-ECC?path=Trenz_Electronic/PCIe_Cards/TEF1001/REV02/Documents
then the I2C addresses are:
a. 0x40 is the DCDC U3 LTM4676A, which provides 4V and 1.5V.
b. 0x4f is the DCDC U4 LTM4676A, which provides 1V.
c. https://www.analog.com/media/en/technical-documentation/data-sheets/4676afa.pdf contains:
      "The LTM4676A always responds to its global slave addresses, 0x5A and 0x5B."

   Which explains that 0x5a and 0x5b are the LTM4676A DCDC converters.
d. 0x70 is the Si5338A programmable quad PLL clock generator on-board.
e. 0x74 is the FAN1 control in the CPLD.


After fitting the DDR3 module (https://web.archive.org/web/20160904161832/http://www.crucial.com/usa/en/ct102472bf160b#productDetails)
the result from the first probe was:
[mr_halfword@skylake-alma coverage]$ i2c_probe/i2c_probe 
Opening device 0000:15:00.0 (10ee:7024) with IOMMU group 41
Using BAR 0 in device 0000:15:00.0 of size 0x2000
Slave 0x19 replied with data 0x00
Slave 0x31 replied with data 0xff
Slave 0x40 replied with data 0xff
Slave 0x4f replied with data 0xff
Slave 0x51 replied with data 0x92
Slave 0x5a replied with data 0xff
Slave 0x5b replied with data 0xff
Slave 0x70 replied with data 0x01
Slave 0x74 replied with data 0xff

Running again got:
[mr_halfword@skylake-alma coverage]$ i2c_probe/i2c_probe 
Opening device 0000:15:00.0 (10ee:7024) with IOMMU group 41
Using BAR 0 in device 0000:15:00.0 of size 0x2000
Slave 0x0c replied with data 0x9e
Slave 0x19 replied with data 0x00
Slave 0x31 replied with data 0xff
Slave 0x40 replied with data 0xff
Slave 0x4f replied with data 0xff
Slave 0x51 replied with data 0x0b
Slave 0x5a replied with data 0xff
Slave 0x5b replied with data 0xff
Slave 0x70 replied with data 0x26
Slave 0x74 replied with data 0xae

Think the Slave 0x0c is spurious, since on further runs didn't get a reply.

To try and identify the I2C addresses for the DDR3 SODIMM:
a. https://media-www.micron.com/-/media/client/global/documents/products/data-sheet/modules/sodimm/ksf18c256_512_1gx72hz.pdf?rev=46354f659a7f4f69af156d4bd634b8db
   is a spec for a 204-Pin DDR3L SODIMM with ECC. Shows the following connections to the SPD EEPROM:
   - EVT - EVENT# (open drain temperature event)
   - A0 - SA0
   - A1 - SA1
   - A2 - Vss
b. https://shop.trenz-electronic.de/trenzdownloads/Trenz_Electronic/PCIe_Cards/TEF1001/REV02/Documents/SCH-TEF1001-02(-160-2I).PDF
   shows for the SODIMM:
   - EVENT# - connected to FPGA via a 1V5 pull-up.
   - SA0 - 3V3
   - SA1 - GND
   - Vdd - 1V5. While the CT102472BF160B is a DDR3L module, is being operated at 1.5V instead of 1.35V
c. https://media-www.micron.com/-/media/client/global/documents/products/technical-note/dram-modules/tn_04_42.pdf?rev=719f35ea22ae4ba0ab5b54b5a991055f
   is "Technical Note Memory Module Serial Presence-Detect".
   Using "Table 2: Device Select Codes" and the above address connections then expect the following:
     Memory Area Function                      Address (7 bits)  Supported R/W 
     READ/WRITE SPD memory                      0x51             Read or Write
     SET WRITE PROTECTION (SWP)                 0x31             Write only
     CLEAR WRITE PROTECTION (CWP)               0x33             Write only
     PERMANENTLY SET WRITE PROTECTION (PSWP)    0x31             Write only
     READ SWP                                   0x31             Read only
     READ PSWP                                  0x31             Read only
     READ/WRITE temperature registers           0x19             Read or Write

After inserting the DDR3 SODIMM the additional I2C addresses probed, via attempted reads, were 0x19, 0x31, 0x51 which are
addresses expected to respond to reads on the DDR3 SODIMM according to the above.

When the "TEF0008 FMC to QSFP+ Module with MAX10" is fitted then:
a. Address 0x50 should be the 24LC128-I/ST EEPROM, addressable by the same I2C interface as the above, via the CPLD.
b. The Si5345A and J4 to J7 SFP+ I2C interfaces are connected by a different I2C interface to the FPGA by dedicated FMC pins.
   The following directions are from the point of view of the TEF0008:
   - SCL In
   - SDA In
   - SDA Out
   - I2C MUX 0: SEL[0]
   - I2C MUX 1: SEL[1]
   - I2C MUX 2: SEL[2]


The following is the result of running "i2c_probe/i2c_probe -i 100000" built for coverage, after a reboot of the PC:
<<snip>>
Iteration 100000 of 100000 using IIC Standard Mode
Slave 0x19 replied with data 0x00
Slave 0x31 replied with data 0xff
Slave 0x40 replied with data 0xff
Slave 0x4f replied with data 0xff
Slave 0x51 replied with data 0x88
Slave 0x5a replied with data 0xff
Slave 0x5b replied with data 0xff
Slave 0x70 replied with data 0x00
Slave 0x74 replied with data 0xae

Number of responses for each I2C address:
0x19 : 100000
0x31 : 99998
0x40 : 100000
0x4f : 100000
0x51 : 100000
0x5a : 100000
0x5b : 100000
0x70 : 100000
0x74 : 100000


The following is the result of running "i2c_probe/i2c_probe -d -i 100000" built for coverage, after a reboot of the PC:
<<snip>>
Iteration 100000 of 100000 using IIC Dynamic Mode
Slave 0x19 replied with data 0x00
Slave 0x31 replied with data 0xff
Slave 0x40 replied with data 0xff
Slave 0x4f replied with data 0xff
Slave 0x51 replied with data 0xff
Slave 0x5a replied with data 0xff
Slave 0x5b replied with data 0xff
Slave 0x70 replied with data 0x00
Slave 0x74 replied with data 0xae

Number of responses for each I2C address:
0x19 : 100000
0x31 : 99999
0x40 : 100000
0x4f : 100000
0x51 : 99999
0x5a : 100000
0x5b : 100000
0x70 : 100000
0x74 : 100000


=== bit-banged I2C controller ===

The following is the result of running the controller built for release when:
a. scl_low() contains a 300 ns delay after setting the SCL output low.
b. Other timing delays are:
#define T_BUF    4700 /* t BUF bus free time between a STOP and START condition */
#define T_SU_STA 4700 /* t SU;STA set-up time for a repeated START condition in Standard Mode */
#define T_HD_STA 4000 /* t HD;STA hold time (repeated) START condition in Standard Mode */
#define T_SU_STO 4000 /* t SU;STO set-up time for STOP condition */
#define T_LOW    4700 /* t LOW LOW period of the SCL clock */
#define T_HIGH   4000 /* t HIGH HIGH period of the SCL clock */

$ i2c_probe/i2c_probe -m bit_banged -n 1 -i 10000 
<<snip>>
Iteration 10000 of 10000 using IIC bit_banged
Slave 0x19 replied with data 0x00
Slave 0x31 replied with data 0xfe
Slave 0x51 replied with data 0xfe
Slave 0x70 replied with data 0x20
Slave 0x74 replied with data 0x5c

Number of responses for each I2C address:
0x19 : 10000
0x31 : 10000
0x40 : 7
0x4f : 4
0x51 : 10000
0x5a : 3
0x5b : 11
0x70 : 10000
0x74 : 10000

The following I2C addresses reliable get an ACK:
- 0x19 : DDR READ/WRITE temperature registers
- 0x31 : DDR READ SWP or READ PSWP
- 0x51 : READ/WRITE SPD memory
- 0x70 : Si5338A programmable quad PLL clock generator
- 0x74 : CPLD fan control

The following I2C addresses intermittently get an ACK:
- 0x40, 0x4f : LTM4676A programmed addresses
- 0x5a, 0x5b : LTM4676A global addresses


Modified to add the following delays after each change of SCL or SDA, to allow to signal transition times:
#define T_RISE   1000 /* t r rise time of both SDA and SCL signals */
#define T_FALL    300 /* t f fall time of both SDA and SCL signals */

Which resulted in all addresses reliably getting an ACK, when compiled for release:
$ i2c_probe/i2c_probe -m bit_banged -n 1 -i 10000 
Iteration 10000 of 10000 using IIC bit_banged
Slave 0x19 replied with data 0x00
Slave 0x31 replied with data 0xfe
Slave 0x40 replied with data 0xfe
Slave 0x4f replied with data 0xfe
Slave 0x51 replied with data 0xfe
Slave 0x5a replied with data 0xfe
Slave 0x5b replied with data 0xfe
Slave 0x70 replied with data 0x00
Slave 0x74 replied with data 0x5c

Number of responses for each I2C address:
0x19 : 10000
0x31 : 10000
0x40 : 10000
0x4f : 10000
0x51 : 10000
0x5a : 10000
0x5b : 10000
0x70 : 10000
0x74 : 10000


== i2c_dump_info results ==

$ i2c_probe/i2c_dump_info 
Opening device 0000:15:00.0 (10ee:7024) with IOMMU group 41
Using BAR 0 in device 0000:15:00.0 of size 0x2000
FAN Control register = 0xfe (fan Enabled)
FAN1 Revolutions per second = 90 (5400 RPM)
DDR temperature Capabilities = 0x00de
DDR temperature configuration register = 0x0000
DDR temperature high limit register = 0x0000 (0.0 C)
DDR temperature low limit register = 0x0000 (0.0 C)
DDR temperature critical limit register = 0x0000 (0.0 C)
DDR ambient temperature register = 0x82e0 above TCRIT (46.0 C)
DDR temperature sensor manufacturer ID register = 0x2094

Notes:
a. The DDR temperature looks reasonable.
   If run multiple times after the PC has been powered on can see the reported temperature
b. The DDR limit registers and the configuration register all read as zero, which is the documented default.
c. The TCRIT flag is set in the ambient temperature register, but that is explained by the temperature critical limit register
   being zero.
d. The documentation for the v3 CPLD FAN control register says bit 7 is the fan enable bit, which the above code uses
   to report if the fan is enabled.
   However, the v2 CPLD source code show FAN control register bit 0 is the fan enable bit. Based on that, the fan PWM is
   actually disabled - which might cause the fan to then run at a default speed.

   https://shop.trenz-electronic.de/en/25130-Heat-Sink-including-fan-for-Trenz-Electronic-TEB0911-and-TEF1001-Series says
   the fan type is "EFB0512HA" which is quoted as a a 5500 RPM fan, which is close the to reported RPM.
d. Not sure why the CPLD FAN register fail to read when attempt a repeated start transaction.
e. Did try and monify the CPLD FAN registers but although the FAN control register is supposed to be read/write:
   - Most of the write attempts fail to affect the readback value
   - When the readback value does change the value isn't that written. Could be the value written to the FAN PWM register
     is the value which actually gets written to the FAN control register.

   A power-cycle restores the register values reported by i2c_dump_info, so the changes are volatile.
f. Unable to find who is the sensor manufacturer ID.
